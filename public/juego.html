<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Runa Defenders: La Furia del Grano</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    
    <!-- Three.js Library -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>

    <style>
        :root {
            --ui-bg: rgba(58, 46, 42, 0.75);
            --text-light: #fdfbf8;
            --accent-color: #D47500;
            --bar-bg: #3a2e2a;
            --power-bar-fill: #fde047; /* Amarillo para la barra de poder */
            --damage-flash-color: rgba(255, 0, 0, 0.3);
            --tree-health-bar-color: #7CFC00;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
        }

        body {
            font-family: 'Press Start 2P', cursive;
            color: var(--text-light);
        }

        #loading-screen {
            position: absolute;
            inset: 0;
            background: #1a1310;
            color: var(--text-light);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 5vmin;
            z-index: 200;
            transition: opacity 0.5s ease;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden; 
        }

        #background-wrapper {
            position: absolute;
            width: 125%; 
            height: 100%;
            top: 0;
            left: 0;
            background: url('https://raw.githubusercontent.com/Yanzsmartwood2025/Runacoffee/e60d103dfb61c7d07d0fe214e620173998d7c7ce/public/assets/imagenes/fondo-del-juego.jpg') no-repeat;
            background-size: 100% 100%;
            transform: translateX(-20%);
            transition: transform 1.2s ease-in-out;
        }

        #game-container.playing #background-wrapper {
            transform: translateX(0);
        }

        #tree-container {
            position: absolute;
            left: 2.5%;
            top: 50%;
            transform: translateY(-50%);
            width: 20%;
            padding-top: 20%; 
            height: 0;
        }

        #tree-health-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: var(--tree-health-bar-color);
            box-shadow: 0 0 10px var(--tree-health-bar-color), 0 0 20px var(--tree-health-bar-color);
            transition: height 0.3s ease-out;
            z-index: 1;
            border-radius: 0 0 50vw 50vw;
        }
        
        #tree-canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            border-radius: 50%;
            overflow: hidden;
        }

        #game-canvas {
            position: absolute;
            left: 25%;
            top: 22%;
            width: 57%; 
            height: 56%;
            background: transparent;
        }

        #damage-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--damage-flash-color);
            opacity: 0;
            transition: opacity 0.1s ease-out;
            pointer-events: none;
            z-index: 99;
        }

        #top-bar, #bottom-bar {
            position: absolute;
            left: 25%;
            width: 71%;
            height: 15%;
            background-color: var(--ui-bg);
            display: flex;
            justify-content: space-around;
            align-items: center;
            border-radius: 15px;
            padding: 0 10px;
        }
        #top-bar { top: 4%; }
        #bottom-bar { bottom: 4%; justify-content: center; gap: 20px; }

        .ui-element {
            display: flex;
            align-items: center;
            background-color: var(--bar-bg);
            padding: 1vmin 2.5vmin;
            border-radius: 8px;
            border: 3px solid #6d4c35;
            color: var(--text-light);
            font-size: 2.5vmin;
            text-shadow: 2px 2px #000;
        }
        
        #level-display {
             padding: 1.5vmin 3vmin;
        }

        #top-power-bar-container {
            width: 25vmin;
            height: 3vmin;
            background-color: #2a1d1a;
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid #6d4c35;
        }
        #top-power-bar {
            width: 0%;
            height: 100%;
            background-color: #ccc; 
            transition: width 0.2s linear;
        }

        #coffee-bag-container {
            gap: 15px;
        }
        #coffee-bag-icon {
            width: 8vmin;
            height: 8vmin;
            transition: transform 0.15s ease-in-out;
        }
        #coffee-bean-counter {
            font-size: 4vmin;
            min-width: 3ch;
            text-align: left;
        }

        #special-power-bar-container {
            width: 30vmin;
            height: 4vmin;
            background-color: #2a1d1a;
            border-radius: 5px;
            overflow: hidden;
            border: 3px solid #6d4c35;
        }
        #special-power-bar {
            width: 0%;
            height: 100%;
            background-color: var(--power-bar-fill);
            transition: width 0.2s linear;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }

        @keyframes pulse-animation {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        .pulse {
            animation: pulse-animation 0.3s ease-in-out;
        }


        #game-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            text-align: center;
            color: white;
            padding: 20px;
            opacity: 1;
            transition: opacity 0.3s ease;
        }
        #game-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .overlay-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .overlay-screen.visible {
            display: flex;
        }
        
        .overlay-screen h1, .overlay-screen h2 { margin-bottom: 20px; color: var(--accent-color); text-shadow: 4px 4px #000; }
        .overlay-screen h1 { font-size: 8vmin; }
        .overlay-screen h2 { font-size: 6vmin; }
        .overlay-screen p { font-size: 3vmin; max-width: 80%; line-height: 1.5; }

        .game-button {
            font-family: 'Press Start 2P', cursive;
            font-size: 4vmin;
            padding: 15px 30px;
            background: var(--accent-color);
            border: none;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 30px;
            text-shadow: 2px 2px #000;
            border-bottom: 5px solid #a15a00;
            transition: all 0.1s ease;
        }
        .game-button:active { transform: translateY(3px); border-bottom-width: 2px; }

    </style>
</head>
<body>
    <div id="loading-screen">Cargando...</div>

    <div id="game-container">
        <div id="background-wrapper"></div>

        <div id="tree-container">
            <div id="tree-health-bar"></div>
            <div id="tree-canvas-container"></div>
        </div>
        
        <div id="top-bar">
             <div id="level-display" class="ui-element">
                 Nivel: <span id="level-value">1</span>
             </div>
             <div id="top-power-bar-container">
                 <div id="top-power-bar"></div>
             </div>
        </div>

        <canvas id="game-canvas"></canvas>
        <div id="damage-flash"></div>

        <div id="bottom-bar">
             <div id="coffee-bag-container" class="ui-element">
                <img id="coffee-bag-icon" src="https://raw.githubusercontent.com/Yanzsmartwood2025/Runacoffee/83b2c2b337c8d090db5bc039cacfd59228f2747a/public/assets/imagenes/ui_coffee_bag.png" alt="Bolsa de Café">
                <span id="coffee-bean-counter">0</span>
             </div>
             <div id="special-power-bar-container">
                <div id="special-power-bar"></div>
             </div>
        </div>

        <div id="game-overlay" class="hidden">
            <div id="start-screen" class="overlay-screen">
                <h1>Runa Defenders</h1>
                <p>¡Las plagas atacan! Defiende tu cosecha.</p>
                <button id="start-button" class="game-button">Empezar</button>
            </div>
            <div id="game-over-screen" class="overlay-screen">
                <h1>¡Defensa Caída!</h1>
                <p>Las plagas han superado tus defensas.</p>
                <button id="retry-button" class="game-button">Volver a Intentar</button>
            </div>
            <div id="level-complete-screen" class="overlay-screen">
                <h2 id="level-complete-title"></h2>
                <div id="level-complete-content"></div>
            </div>
        </div>
    </div>
    
<script type="module">
    // =================================================================
    // --- 3D SCENE MODULE ---
    // =================================================================
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    let treeScene, treeCamera, treeRenderer, treeModel;
    const treeCanvasContainer = document.getElementById('tree-canvas-container');
    const treeHealthBar = document.getElementById('tree-health-bar');
    const healthyColor = new THREE.Color(0xffffff);
    const damagedColor = new THREE.Color(0xff0000);

    function initThreeScene() {
        treeScene = new THREE.Scene();

        const { width, height } = treeCanvasContainer.getBoundingClientRect();
        treeCamera = new THREE.PerspectiveCamera(40, width / height, 0.1, 1000);
        treeCamera.position.set(0, 1.2, 7);
        treeCamera.lookAt(0, 0.8, 0);

        treeRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        treeRenderer.setClearColor(0x000000, 0);
        treeRenderer.setSize(width, height);
        treeRenderer.setPixelRatio(window.devicePixelRatio);
        treeRenderer.outputColorSpace = THREE.SRGBColorSpace;
        treeCanvasContainer.appendChild(treeRenderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
        treeScene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
        directionalLight.position.set(5, 10, 7.5);
        treeScene.add(directionalLight);
        
        const loader = new GLTFLoader();
        loader.load('https://raw.githubusercontent.com/Yanzsmartwood2025/Runacoffee/776b9c0c5a976bff5e8077da365a60a5e5c3e616/public/assets%20/3D/arbol_final.glb', (gltf) => {
            treeModel = gltf.scene;
            const box = new THREE.Box3().setFromObject(treeModel);
            const center = box.getCenter(new THREE.Vector3());
            treeModel.position.y -= box.min.y;
            treeModel.position.add(center.multiplyScalar(-1));
            
            treeModel.scale.set(1.6, 1.6, 1.6);
            treeScene.add(treeModel);
            if (base) {
                updateTreeAppearance();
            }
        }, undefined, (error) => {
            console.error('An error happened while loading the tree model:', error);
        });

        function animateTree() {
            requestAnimationFrame(animateTree);
            treeRenderer.render(treeScene, treeCamera);
        }
        animateTree();
        
        const resizeObserver = new ResizeObserver(() => {
            const { width, height } = treeCanvasContainer.getBoundingClientRect();
            if (width > 0 && height > 0) {
                treeCamera.aspect = width / height;
                treeCamera.updateProjectionMatrix();
                treeRenderer.setSize(width, height);
            }
        });
        resizeObserver.observe(treeCanvasContainer);
    }

    function updateTreeAppearance() {
        if (!base || !treeModel) return;
        const healthPercent = Math.max(0, base.health / base.maxHealth);
        
        if (treeHealthBar) {
            treeHealthBar.style.height = `${healthPercent * 100}%`;
        }

        treeModel.traverse((node) => {
            if (node.isMesh && node.material) {
                if (!node.material.originalColor) {
                    node.material.originalColor = node.material.color.clone();
                }
                node.material.color.copy(node.material.originalColor).lerp(damagedColor, 1 - healthPercent);
            }
        });
    }

    // =================================================================
    // --- FIREBASE INTEGRATION ---
    // =================================================================
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    let app, auth, db, userId = null;
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfigStr = typeof __firebase_config !== 'undefined' ? __firebase_config : '{}';
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    function initializeFirebase() {
        try {
            const firebaseConfig = JSON.parse(firebaseConfigStr);
            if (Object.keys(firebaseConfig).length > 0) {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        await loadGameData();
                    }
                });

                if (!auth.currentUser) {
                    signInAnonymously(auth).catch(error => console.error("Anonymous sign-in failed:", error));
                }

            } else {
                 console.log("Firebase config not found. Running in offline mode.");
            }
        } catch (e) { 
            console.error("Firebase initialization failed:", e);
        }
    }
    
    async function saveGameData() {
        if (!userId || !db) return;
        const gameDataRef = doc(db, `artifacts/${appId}/users/${userId}/runa_defenders_h`, 'progress');
        const dataToSave = {
            level: currentLevelIndex,
            specialPower: specialPowerPoints,
            coffeeBeans: coffeeBeanCount,
            baseHealth: base.health,
            timestamp: new Date()
        };
        try { await setDoc(gameDataRef, dataToSave, { merge: true }); } 
        catch (error) { console.error("Error saving game:", error); }
    }

    async function loadGameData() {
        if (!userId || !db) return;
        const gameDataRef = doc(db, `artifacts/${appId}/users/${userId}/runa_defenders_h`, 'progress');
        try {
            const docSnap = await getDoc(gameDataRef);
            if (docSnap.exists()) {
                const data = docSnap.data();
                init(data.level || 0, data.specialPower || 0, data.coffeeBeans || 0, data.baseHealth || config.base.health, false);
            }
        } catch (error) {
            console.error("Error loading game:", error);
        }
    }

    // =================================================================
    // ---  GAME CONFIG & MAIN LOGIC ---
    // =================================================================
    const config = {
        // --- CAMBIO: Reducido a 4 carriles para hacer todo más grande ---
        lanes: 4, 
        playerSpeed: 5, projectileSpeed: 8, shootCooldown: 20, 
        specialPowerMax: 100, orbValue: 10, healingValue: 25,
        player: {}, base: { health: 1000 },
        grainImage: 'https://raw.githubusercontent.com/Yanzsmartwood2025/Runacoffee/83b2c2b337c8d090db5bc039cacfd59228f2747a/public/assets/imagenes/collectible_coffee_bean.png',
        orbImage: 'https://raw.githubusercontent.com/Yanzsmartwood2025/Runacoffee/83b2c2b337c8d090db5bc039cacfd59228f2747a/public/assets/imagenes/collectible_power_orb.png',
        enemies: [], levels: []
    };
    Object.assign(config, {
        player: {
            image: { 
                idle: 'https://raw.githubusercontent.com/Yanzsmartwood2025/Runacoffee/83b2c2b337c8d090db5bc039cacfd59228f2747a/public/assets/imagenes/player.png',
                attack: 'https://raw.githubusercontent.com/Yanzsmartwood2025/Runacoffee/83b2c2b337c8d090db5bc039cacfd59228f2747a/public/assets/imagenes/player.png'
            },
            projectileImage: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAyMCI+PGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iOCIgZmlsbD0iI2Q0NzUwMCIvPjwvc3ZnPg=='
        },
        enemies: [
            { name: 'Broca Débil', health: 20, speed: 0.5, grainChance: 0.8, orbChance: 0.1, image: 'https://raw.githubusercontent.com/Yanzsmartwood2025/Runacoffee/83b2c2b337c8d090db5bc039cacfd59228f2747a/public/assets/imagenes/enemy_broca_1.png' },
            { name: 'Broca Normal', health: 60, speed: 0.4, grainChance: 0.5, orbChance: 0.2, image: 'https://raw.githubusercontent.com/Yanzsmartwood2025/Runacoffee/83b2c2b337c8d090db5bc039cacfd59228f2747a/public/assets/imagenes/enemy_broca_2.png' },
            { name: 'Broca Fuerte', health: 300, speed: 0.3, grainChance: 0.2, orbChance: 0.5, image: 'https://raw.githubusercontent.com/Yanzsmartwood2025/Runacoffee/83b2c2b337c8d090db5bc039cacfd59228f2747a/public/assets/imagenes/enemy_broca_3.png' },
        ],
        levels: [
            { duration: 180, waves: [ { startTime: 2, enemyType: 0, spawnInterval: 240 }, { startTime: 30, enemyType: 0, spawnInterval: 180 }, { startTime: 70, enemyType: 1, spawnInterval: 480 }, { startTime: 120, enemyType: 0, spawnInterval: 120 }, { startTime: 160, enemyType: 1, spawnInterval: 300 } ]},
            { duration: 180, waves: [ { startTime: 2, enemyType: 0, spawnInterval: 150 }, { startTime: 20, enemyType: 1, spawnInterval: 240 }, { startTime: 60, enemyType: 0, spawnInterval: 90 }, { startTime: 100, enemyType: 1, spawnInterval: 180 }, { startTime: 140, enemyType: 2, spawnInterval: 900 } ]}
        ]
    });

    const loadingScreen = document.getElementById('loading-screen');
    const gameContainer = document.getElementById('game-container');
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const gameOverlay = document.getElementById('game-overlay');
    const specialPowerBar = document.getElementById('special-power-bar');
    const levelValue = document.getElementById('level-value');
    const damageFlash = document.getElementById('damage-flash');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const levelCompleteScreen = document.getElementById('level-complete-screen');
    const startButton = document.getElementById('start-button');
    const retryButton = document.getElementById('retry-button');
    const coffeeBagIcon = document.getElementById('coffee-bag-icon');
    const coffeeBeanCounterEl = document.getElementById('coffee-bean-counter');

    let cellSize, player, base;
    let projectiles = [], enemies = [], resources = [];
    let currentLevelIndex = 0, shootTimer = 0, animationFrameId;
    let specialPowerPoints = 0, coffeeBeanCount = 0;
    let levelTimer = 0, currentWaveIndex = -1, spawnTimer = 0;
    let gameState = 'loading';
    let globalAnimationTimer = 0;

    const sounds = {
        shoot: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination(),
        collect: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 } }).toDestination(),
        heal: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.2 } }).toDestination(),
        baseHit: new Tone.MembraneSynth({ pitchDecay: 0.1, octaves: 2, envelope: { attack: 0.01, decay: 0.3, sustain: 0.01, release: 0.4 } }).toDestination(),
        enemyHit: new Tone.PolySynth(Tone.NoiseSynth, { noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.05 } }).toDestination(),
        gameOver: new Tone.PolySynth(Tone.Synth).toDestination(),
        levelUp: new Tone.PolySynth(Tone.Synth).toDestination(),
    };

    function playSound(sound, note, duration = '8n') {
        if (Tone.context.state !== 'running') return;
        if (sounds[sound]) sounds[sound].triggerAttackRelease(note, duration);
    }
    
    class Player {
        constructor() { this.reset(); }
        reset() {
            this.width = cellSize * 0.9;
            this.height = cellSize * 0.9;
            this.x = 10; 
            this.baseY = canvas.height / 2 - this.height / 2;
            this.y = this.baseY;
            this.speed = config.playerSpeed;
            this.image = new Image();
            this.image.src = config.player.image.idle;
            this.attackImage = new Image();
            this.attackImage.src = config.player.image.attack;
            this.isAttacking = false;
        }
        draw() {
            const bobble = Math.sin(globalAnimationTimer * 4) * (cellSize * 0.02);
            ctx.drawImage(this.isAttacking ? this.attackImage : this.image, this.x, this.y + bobble, this.width, this.height);
        }
        update() {
            if (this.y < 0) this.y = 0;
            if (this.y > canvas.height - this.height) this.y = canvas.height - this.height;
        }
        shoot() {
            if (shootTimer > 0 || gameState !== 'playing') return;
            projectiles.push(new Projectile(this.x + this.width, this.y + this.height / 2));
            shootTimer = config.shootCooldown;
            playSound('shoot', 'C5', '16n');
            this.isAttacking = true;
            setTimeout(() => this.isAttacking = false, 100);
        }
    }
    class Projectile {
        constructor(x, y) {
            this.x = x; this.y = y - 10; this.width = 20; this.height = 20;
            this.speed = config.projectileSpeed; this.power = 20;
            this.image = new Image(); this.image.src = config.player.projectileImage;
        }
        update() { this.x += this.speed; }
        draw() { ctx.drawImage(this.image, this.x, this.y, this.width, this.height); }
    }
    class Enemy {
        constructor(lane, typeIndex) {
            this.type = config.enemies[typeIndex];
            this.width = cellSize - 10; this.height = cellSize - 10;
            this.x = canvas.width; 
            this.baseY = (lane * cellSize) + 5;
            this.y = this.baseY;
            this.speed = this.type.speed; this.health = this.type.health;
            this.maxHealth = this.health;
            this.image = new Image(); this.image.src = this.type.image;
        }
        update() { this.x -= this.speed; }
        draw() { 
            const bobble = Math.sin(globalAnimationTimer * 5 + this.baseY) * (cellSize * 0.05);
            ctx.drawImage(this.image, this.x, this.y + bobble, this.width, this.height);
            
            if (this.health < this.maxHealth) {
                ctx.fillStyle = 'red'; ctx.fillRect(this.x, this.y - 10 + bobble, this.width, 5);
                ctx.fillStyle = 'green'; ctx.fillRect(this.x, this.y - 10 + bobble, this.width * (this.health / this.maxHealth), 5);
            }
        }
    }
    class Resource {
        constructor(x, y, type) {
            this.x = x; this.y = y; 
            this.size = 45; 
            this.type = type;
            this.image = new Image(); this.image.src = type === 'grain' ? config.grainImage : config.orbImage;
            this.life = 400;
            this.isFlying = false;
        }
        update() { this.life--; }
        draw() {
            if (this.isFlying) return;
            const scale = 1 + Math.sin(globalAnimationTimer * 6) * 0.08;
            const newSize = this.size * scale;
            const sizeDiff = (newSize - this.size) / 2;

            ctx.globalAlpha = this.life < 60 ? this.life / 60 : 1;
            ctx.drawImage(this.image, this.x - sizeDiff, this.y - sizeDiff, newSize, newSize);
            ctx.globalAlpha = 1;
        }
    }

    function isColliding(a,b){ return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y; }
    function triggerDamageFlash() {
        damageFlash.style.opacity = 1;
        setTimeout(() => { damageFlash.style.opacity = 0; }, 150);
    }

    function handleCollisions() {
        for (let i = projectiles.length - 1; i >= 0; i--) {
            for (let j = enemies.length - 1; j >= 0; j--) {
                if (projectiles[i] && enemies[j] && isColliding(projectiles[i], enemies[j])) {
                    enemies[j].health -= projectiles[i].power; projectiles.splice(i, 1); playSound('enemyHit');
                    if (enemies[j].health <= 0) {
                        const enemyType = enemies[j].type;
                        if (Math.random() < enemyType.grainChance) resources.push(new Resource(enemies[j].x, enemies[j].y, 'grain'));
                        if (Math.random() < enemyType.orbChance) resources.push(new Resource(enemies[j].x, enemies[j].y, 'orb'));
                        enemies.splice(j, 1);
                    }
                    break; 
                }
            }
        }
        for (let i = enemies.length - 1; i >= 0; i--) {
            if (enemies[i].x < player.x + player.width) { 
                base.health -= 50; updateTreeAppearance(); triggerDamageFlash(); playSound('baseHit', 'C2', '4n');
                enemies.splice(i, 1);
                if (base.health <= 0) { gameState = 'game_over'; playSound('gameOver', 'C3', '1n'); }
            }
        }
    }
    
    function handleGameLogic() {
        globalAnimationTimer += 0.02;
        if (shootTimer > 0) shootTimer--;
        levelTimer += 1/60;
        projectiles.forEach((p, i) => { p.update(); if (p.x > canvas.width) projectiles.splice(i, 1); });
        enemies.forEach(e => e.update());
        resources.forEach((r, i) => { r.update(); if (r.life <= 0) resources.splice(i, 1); });
        handleCollisions();
        handleLevelProgression();
    }

    function handleLevelProgression() {
        if (gameState !== 'playing') return;
        const currentLevel = config.levels[currentLevelIndex];
        const nextWaveIndex = currentWaveIndex + 1;
        if (nextWaveIndex < currentLevel.waves.length && levelTimer >= currentLevel.waves[nextWaveIndex].startTime) {
            currentWaveIndex = nextWaveIndex; spawnTimer = 0;
        }
        if (levelTimer >= currentLevel.duration && enemies.length === 0) { startNextLevel(); return; }
        if (currentWaveIndex > -1) {
            if (spawnTimer > 0) spawnTimer--;
            else if (enemies.length < 20) { spawnEnemy(); spawnTimer = currentLevel.waves[currentWaveIndex].spawnInterval; }
        }
    }

    function startNextLevel() { gameState = 'level_complete'; saveGameData(); showOverlay('level_complete'); }
    function spawnEnemy() {
        const currentWave = config.levels[currentLevelIndex].waves[currentWaveIndex];
        enemies.push(new Enemy(Math.floor(Math.random() * config.lanes), currentWave.enemyType));
    }

    function draw() { 
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (player) player.draw();
        projectiles.forEach(p => p.draw());
        enemies.forEach(e => e.draw());
        resources.forEach(r => r.draw());
    }

    function updateUI() { 
        levelValue.textContent = currentLevelIndex + 1;
        coffeeBeanCounterEl.textContent = coffeeBeanCount;
        specialPowerBar.style.width = `${(specialPowerPoints / config.specialPowerMax) * 100}%`;
    }

    function gameLoop() {
        if (gameState === 'playing') handleGameLogic();
        draw();
        
        if (gameState === 'game_over') showOverlay('game_over');
        else if (gameState !== 'level_complete') animationFrameId = requestAnimationFrame(gameLoop);
    }

    function showOverlay(type) {
        if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }

        gameContainer.classList.remove('playing');
        gameOverlay.classList.remove('hidden');

        startScreen.classList.remove('visible');
        gameOverScreen.classList.remove('visible');
        levelCompleteScreen.classList.remove('visible');

        if (type === 'start') {
            startButton.textContent = `Empezar Nivel ${currentLevelIndex + 1}`;
            startScreen.classList.add('visible');
        } else if (type === 'game_over') {
            gameOverScreen.classList.add('visible');
        } else if (type === 'level_complete') {
            const nextLevelExists = currentLevelIndex + 1 < config.levels.length;
            levelCompleteScreen.querySelector('h2').textContent = `¡Nivel ${currentLevelIndex + 1} Superado!`;
            const content = levelCompleteScreen.querySelector('div');
            if (nextLevelExists) {
                content.innerHTML = `<button id="next-level-button" class="game-button">Siguiente Nivel</button>`;
                content.querySelector('button').addEventListener('click', () => {
                    currentLevelIndex++; init(currentLevelIndex, specialPowerPoints, coffeeBeanCount, base.health, false);
                }, { once: true });
            } else {
                content.innerHTML = `<h1>¡VICTORIA TOTAL!</h1><p>¡Has defendido la cosecha!</p>`;
            }
            levelCompleteScreen.classList.add('visible');
        }
    }

    function init(level = 0, power = 0, beans = 0, health = config.base.health, isFirstLoad = true) {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        
        currentLevelIndex = level;
        specialPowerPoints = power;
        coffeeBeanCount = beans;
        base = { health: Math.min(health, config.base.health), maxHealth: config.base.health };
        
        levelTimer = 0; currentWaveIndex = -1;
        enemies = []; projectiles = []; resources = [];

        resizeAll(); 
        updateTreeAppearance();
        updateUI();
        
        gameState = 'start';
        showOverlay('start');

        if (isFirstLoad) {
            loadingScreen.style.opacity = '0';
            setTimeout(() => { loadingScreen.style.display = 'none'; }, 500);
        }
    }

    function setupEventListeners() {
        const handleStart = async (event) => {
            event.preventDefault();
            try { if (Tone.context.state !== 'running') await Tone.start(); } 
            catch (e) { console.error("Could not start audio context:", e); }

            gameState = 'playing';
            gameContainer.classList.add('playing');
            gameOverlay.classList.add('hidden');
            spawnTimer = 0;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
        };
        startButton.addEventListener('click', handleStart);

        retryButton.addEventListener('click', (e) => { e.preventDefault(); init(currentLevelIndex, 0, 0, config.base.health, false); });

        let keys = {};
        window.addEventListener('keydown', e => { keys[e.key] = true; if (e.key === ' ' || e.key.includes('Arrow')) e.preventDefault(); });
        window.addEventListener('keyup', e => { keys[e.key] = false; });
        
        function controlLoop() {
            if (gameState === 'playing') {
                if (keys['w'] || keys['ArrowUp']) player.y -= player.speed;
                if (keys['s'] || keys['ArrowDown']) player.y += player.speed;
                if (keys[' ']) player.shoot();
                if (player) player.update();
            }
            requestAnimationFrame(controlLoop);
        }
        controlLoop();

        let isDragging = false, didDrag = false, touchYOffset = 0, touchStartY = 0;
        canvas.addEventListener('touchstart', e => {
            e.preventDefault(); const touch = e.touches[0]; const rect = canvas.getBoundingClientRect();
            isDragging = true; didDrag = false;
            const currentY = touch.clientY - rect.top;
            touchStartY = currentY; touchYOffset = currentY - player.y;
        }, { passive: false });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault(); if (!isDragging) return;
            const touch = e.touches[0]; const rect = canvas.getBoundingClientRect();
            const newY = touch.clientY - rect.top;
            if (Math.abs(newY - touchStartY) > 5) didDrag = true;
            if (player) player.y = newY - touchYOffset;
        }, { passive: false });

        canvas.addEventListener('touchend', e => {
            e.preventDefault(); if (didDrag || !player) return;
            player.shoot();
            const rect = canvas.getBoundingClientRect();
            const clickX = e.changedTouches[0].clientX - rect.left;
            const clickY = e.changedTouches[0].clientY - rect.top;
            checkResourceClick(clickX, clickY);
        });

        canvas.addEventListener('click', e => {
            if (!player) return;
            const rect = canvas.getBoundingClientRect();
            checkResourceClick(e.clientX - rect.left, e.clientY - rect.top);
            player.shoot();
        });
    }

    function checkResourceClick(x, y) {
        for (let i = resources.length - 1; i >= 0; i--) {
            const r = resources[i];
            if (r.isFlying) continue;

            const dist = Math.sqrt(Math.pow(x - (r.x + r.size/2), 2) + Math.pow(y - (r.y + r.size/2), 2));
            
            if (dist < r.size) { 
                if (r.type === 'grain') {
                    r.isFlying = true;
                    animateResourceToBag(r);
                } else {
                    specialPowerPoints = Math.min(config.specialPowerMax, specialPowerPoints + config.orbValue);
                    playSound('collect', 'G5');
                    updateUI();
                    resources.splice(i, 1);
                }
                break;
            }
        }
    }

    function animateResourceToBag(resource) {
        const flyingBean = new Image();
        flyingBean.src = config.grainImage;
        flyingBean.style.position = 'absolute';
        flyingBean.style.zIndex = '999';
        flyingBean.style.width = `${resource.size}px`;
        flyingBean.style.height = `${resource.size}px`;

        const canvasRect = canvas.getBoundingClientRect();
        const bagRect = coffeeBagIcon.getBoundingClientRect();

        const startX = canvasRect.left + resource.x;
        const startY = canvasRect.top + resource.y;
        
        const endX = bagRect.left + bagRect.width / 2 - resource.size / 2;
        const endY = bagRect.top + bagRect.height / 2 - resource.size / 2;

        flyingBean.style.left = `${startX}px`;
        flyingBean.style.top = `${startY}px`;

        document.body.appendChild(flyingBean);

        requestAnimationFrame(() => {
            flyingBean.style.transition = 'left 0.8s ease-in, top 0.8s ease-out, transform 0.8s ease-in, opacity 0.5s 0.5s';
            flyingBean.style.left = `${endX}px`;
            flyingBean.style.top = `${endY}px`;
            flyingBean.style.transform = 'scale(0.2)';
            flyingBean.style.opacity = '0.5';
        });

        flyingBean.addEventListener('transitionend', () => {
            base.health = Math.min(base.maxHealth, base.health + config.healingValue);
            coffeeBeanCount++;
            updateTreeAppearance();
            updateUI();
            playSound('heal', 'A5');

            coffeeBagIcon.classList.add('pulse');
            setTimeout(() => coffeeBagIcon.classList.remove('pulse'), 300);

            document.body.removeChild(flyingBean);
            const originalResourceIndex = resources.findIndex(res => res === resource);
            if (originalResourceIndex > -1) {
                resources.splice(originalResourceIndex, 1);
            }
        }, { once: true });
    }
    
    function resizeAll() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        if (canvas.height > 0) cellSize = canvas.height / config.lanes;
        if (!player) player = new Player();
        else player.reset();
        if(gameState !== 'playing') draw();
    }

    // --- INITIALIZE EVERYTHING ---
    document.addEventListener('DOMContentLoaded', () => {
        setupEventListeners();
        initThreeScene();
        initializeFirebase();
        init(0, 0, 0, config.base.health, true);
        window.addEventListener('resize', resizeAll);
    });
</script>

</body>
</html>
