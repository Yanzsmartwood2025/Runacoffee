<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Runa Defenders: La Furia del Grano</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    
    <!-- Three.js Library -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>

    <style>
        :root {
            --ui-bg: rgba(58, 46, 42, 0.75); /* Semi-transparent UI background */
            --text-light: #fdfbf8;
            --accent-color: #D47500;
            --bar-bg: #3a2e2a;
            --power-bar-fill: #fde047;
            --damage-flash-color: rgba(255, 0, 0, 0.3);
            --tree-health-bar-color: #7CFC00;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
        }

        body {
            font-family: 'Press Start 2P', cursive;
            color: var(--text-light);
        }

        /* --- MODIFIED: Updated background URL to your GitHub raw link --- */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: url('https://raw.githubusercontent.com/Yanzsmartwood2025/Runacoffee/e60d103dfb61c7d07d0fe214e620173998d7c7ce/public/assets/imagenes/fondo-del-juego.jpg') no-repeat center center;
            background-size: cover;
        }

        /* --- NEW LAYOUT: Absolutely positioned elements --- */
        #tree-container {
            position: absolute;
            left: 2.5%;
            top: 50%;
            transform: translateY(-50%);
            width: 20%;
            /* Aspect ratio 1:1 to make it a circle */
            padding-top: 20%; 
            height: 0;
            background: transparent;
            border: none;
        }

        #tree-health-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: var(--tree-health-bar-color);
            box-shadow: 0 0 10px var(--tree-health-bar-color), 0 0 20px var(--tree-health-bar-color);
            transition: height 0.3s ease-out;
            z-index: 1;
            border-radius: 0 0 50vw 50vw;
        }
        
        #tree-canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            border-radius: 50%;
            overflow: hidden;
        }

        #game-canvas {
            position: absolute;
            left: 25%;
            top: 22%;
            width: 71%;
            height: 56%;
            background: transparent;
        }

        #damage-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--damage-flash-color);
            opacity: 0;
            transition: opacity 0.1s ease-out;
            pointer-events: none;
            z-index: 99;
        }

        #top-bar {
            position: absolute;
            top: 4%;
            left: 25%;
            width: 71%;
            height: 15%;
            background-color: var(--ui-bg);
            display: flex;
            justify-content: space-around;
            align-items: center;
            border-radius: 15px;
            padding: 0 10px;
        }
        
        #bottom-bar {
            position: absolute;
            bottom: 4%;
            left: 25%;
            width: 71%;
            height: 15%;
            background-color: var(--ui-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            border-radius: 15px;
        }

        .ui-element {
            display: flex;
            align-items: center;
            background-color: var(--bar-bg);
            padding: 1vmin 2.5vmin;
            border-radius: 8px;
            border: 3px solid #6d4c35;
            color: var(--text-light);
            font-size: 2.5vmin;
            text-shadow: 2px 2px #000;
        }
        
        #level-display {
             padding: 1.5vmin 3vmin;
        }

        #power-bar-container {
            width: 25vmin;
            height: 3vmin;
            background-color: #2a1d1a;
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid #6d4c35;
        }
        #power-bar {
            width: 0%;
            height: 100%;
            background-color: var(--power-bar-fill);
            transition: width 0.2s linear;
        }

        .power-button {
            width: 10vmin;
            height: 10vmin;
            border: 3px solid #6d4c35;
            border-radius: 50%;
            background-color: var(--bar-bg);
            cursor: pointer;
            position: relative;
            opacity: 0.5;
            transition: opacity 0.3s, transform 0.1s;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4vmin;
        }
        .power-button.ready {
            opacity: 1;
            border-color: var(--accent-color);
        }
        .power-button.ready:hover {
            transform: scale(1.1);
        }

        #game-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            text-align: center;
            color: white;
            padding: 20px;
        }
        
        #game-overlay h1, #game-overlay h2 { margin-bottom: 20px; color: var(--accent-color); text-shadow: 4px 4px #000; }
        #game-overlay h1 { font-size: 8vmin; }
        #game-overlay h2 { font-size: 6vmin; }
        #game-overlay p { font-size: 3vmin; max-width: 80%; line-height: 1.5; }

        .game-button {
            font-family: 'Press Start 2P', cursive;
            font-size: 4vmin;
            padding: 15px 30px;
            background: var(--accent-color);
            border: none;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 30px;
            text-shadow: 2px 2px #000;
            border-bottom: 5px solid #a15a00;
            transition: all 0.1s ease;
        }
        .game-button:active { transform: translateY(3px); border-bottom-width: 2px; }

    </style>
</head>
<body>
    <div id="game-container">
        <!-- All game elements are now direct children of the container -->
        <div id="tree-container">
            <div id="tree-health-bar"></div>
            <div id="tree-canvas-container"></div>
        </div>
        
        <div id="top-bar">
             <div id="level-display" class="ui-element">
                 Nivel: <span id="level-value">1</span>
             </div>
             <div id="power-bar-container">
                 <div id="power-bar"></div>
             </div>
        </div>

        <canvas id="game-canvas"></canvas>
        <div id="damage-flash"></div>

        <div id="bottom-bar">
             <button id="power-1" class="power-button">?</button>
             <button id="power-2" class="power-button">?</button>
        </div>

        <div id="game-overlay">
             <h1 id="overlay-title">Runa Defenders</h1>
             <p id="overlay-text">¡Las plagas atacan! Defiende tu cosecha. Mueve a tu Guardián y dispara a los enemigos que vienen de la derecha.</p>
             <button id="start-button" class="game-button">Empezar</button>
        </div>
    </div>
    
<script type="module">
    // =================================================================
    // --- 3D SCENE MODULE ---
    // =================================================================
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    let treeScene, treeCamera, treeRenderer, treeModel;
    const treeCanvasContainer = document.getElementById('tree-canvas-container');
    const treeHealthBar = document.getElementById('tree-health-bar');
    const healthyColor = new THREE.Color(0xffffff);
    const damagedColor = new THREE.Color(0xff0000);

    function initThreeScene() {
        treeScene = new THREE.Scene();

        const { width, height } = treeCanvasContainer.getBoundingClientRect();
        treeCamera = new THREE.PerspectiveCamera(40, width / height, 0.1, 1000);
        treeCamera.position.set(0, 1.2, 7);
        treeCamera.lookAt(0, 0.8, 0);

        treeRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        treeRenderer.setClearColor(0x000000, 0); // Transparent background
        treeRenderer.setSize(width, height);
        treeRenderer.setPixelRatio(window.devicePixelRatio);
        treeRenderer.outputColorSpace = THREE.SRGBColorSpace;
        treeCanvasContainer.appendChild(treeRenderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
        treeScene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
        directionalLight.position.set(5, 10, 7.5);
        treeScene.add(directionalLight);
        
        const loader = new GLTFLoader();
        loader.load('https://raw.githubusercontent.com/Yanzsmartwood2025/Runacoffee/776b9c0c5a976bff5e8077da365a60a5e5c3e616/public/assets%20/3D/arbol_final.glb', (gltf) => {
            treeModel = gltf.scene;
            const box = new THREE.Box3().setFromObject(treeModel);
            const center = box.getCenter(new THREE.Vector3());
            treeModel.position.y -= box.min.y;
            treeModel.position.add(center.multiplyScalar(-1));
            
            treeModel.scale.set(1.2, 1.2, 1.2);
            treeScene.add(treeModel);
            updateTreeAppearance();
        }, undefined, (error) => {
            console.error('An error happened while loading the tree model:', error);
        });

        function animateTree() {
            requestAnimationFrame(animateTree);
            treeRenderer.render(treeScene, treeCamera);
        }
        animateTree();
        
        const resizeObserver = new ResizeObserver(() => {
            const { width, height } = treeCanvasContainer.getBoundingClientRect();
            if (width > 0 && height > 0) {
                treeCamera.aspect = width / height;
                treeCamera.updateProjectionMatrix();
                treeRenderer.setSize(width, height);
            }
        });
        resizeObserver.observe(treeCanvasContainer);
    }

    function updateTreeAppearance() {
        if (!base) return;
        const healthPercent = Math.max(0, base.health / base.maxHealth);
        
        if (treeHealthBar) {
            treeHealthBar.style.height = `${healthPercent * 100}%`;
        }

        if (!treeModel) return;
        treeModel.traverse((node) => {
            if (node.isMesh && node.material) {
                if (!node.material.originalColor) {
                    node.material.originalColor = node.material.color.clone();
                }
                node.material.color.copy(node.material.originalColor).lerp(damagedColor, 1 - healthPercent);
            }
        });
    }

    // =================================================================
    // --- FIREBASE INTEGRATION ---
    // =================================================================
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    let app, auth, db, userId = null;
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfigStr = typeof __firebase_config !== 'undefined' ? __firebase_config : '{}';
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    try {
        const firebaseConfig = JSON.parse(firebaseConfigStr);
        if (Object.keys(firebaseConfig).length > 0) {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
        }
    } catch (e) { console.error("Error al inicializar Firebase:", e); }

    if (auth) {
        onAuthStateChanged(auth, async (user) => {
            if (user) { userId = user.uid; await loadGameData(); } 
            else { userId = null; init(0, 0, config.base.health); }
        });
        if (!auth.currentUser) {
            try {
                if (initialAuthToken) await signInWithCustomToken(auth, initialAuthToken);
                else await signInAnonymously(auth);
            } catch (error) { console.error("Error en la autenticación:", error); }
        }
    } else { init(0, 0, config.base.health); }
    
    async function saveGameData() {
        if (!userId || !db) return;
        const gameDataRef = doc(db, `artifacts/${appId}/users/${userId}/runa_defenders_h`, 'progress');
        const dataToSave = {
            level: currentLevelIndex,
            power: powerPoints,
            baseHealth: base.health,
            timestamp: new Date()
        };
        try { await setDoc(gameDataRef, dataToSave, { merge: true }); } 
        catch (error) { console.error("Error al guardar la partida:", error); }
    }

    async function loadGameData() {
        if (!userId || !db) { init(0, 0, config.base.health); return; }
        const gameDataRef = doc(db, `artifacts/${appId}/users/${userId}/runa_defenders_h`, 'progress');
        try {
            const docSnap = await getDoc(gameDataRef);
            if (docSnap.exists()) {
                const data = docSnap.data();
                init(data.level || 0, data.power || 0, data.baseHealth || config.base.health);
            } else { init(0, 0, config.base.health); }
        } catch (error) {
            console.error("Error al cargar la partida:", error);
            init(0, 0, config.base.health);
        }
    }

    // =================================================================
    // ---  GAME CONFIG & MAIN LOGIC ---
    // =================================================================
    const config = {
        lanes: 6, 
        playerSpeed: 5, projectileSpeed: 8, shootCooldown: 20, 
        powerBarMax: 100, orbValue: 5, healingValue: 25,
        player: {}, base: { health: 1000 },
        grainImage: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAzMCI+PGVsbGlwc2UgY3g9IjEwIiBjeT0iMTUiIHJ4PSI4IiByeT0iMTQiIGZpbGw9IiM2NTQzMjEiLz48L3N2Zz4=',
        orbImage: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAyMCI+PGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiNmZGUwNDciLz48L3N2Zz4=',
        enemies: [], levels: []
    };
    Object.assign(config, {
        player: {
            image: {
                idle: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0MCIgZmlsbD0iIzY1NDMyMSIvPjxwYXRoIGQ9Ik0zMCA1MEE0MCA0MCAwIDAgMCA3MCA1MCIgZmlsbD0iIzM4MjIyMiIvPjwvc3ZnPg==',
                attack: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0MCIgZmlsbD0iIzk5NmI1MCIvPjxwYXRoIGQ9Ik0zMCA1MEE0MCA0MCAwIDAgMCA3MCA1MCIgZmlsbD0iIzM4MjIyMiIvPjwvc3ZnPg=='
            },
            projectileImage: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAyMCI+PGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iOCIgZmlsbD0iI2Q0NzUwMCIvPjwvc3ZnPg=='
        },
        enemies: [
            { name: 'Broca Débil', health: 20, speed: 0.5, grainChance: 0.8, orbChance: 0.1, image: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB4PSIyMCIgeT0iMjAiIHdpZHRoPSI2MCIgaGVpZ2h0PSI2MCIgZmlsbD0iI2M3M2EzYSIvPjwvc3ZnPg==' },
            { name: 'Broca Normal', health: 60, speed: 0.4, grainChance: 0.5, orbChance: 0.2, image: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB4PSIyMCIgeT0iMjAiIHdpZHRoPSI2MCIgaGVpZ2h0PSI2MCIgZmlsbD0iI2M3N2IzYSIvPjwvc3ZnPg==' },
            { name: 'Broca Fuerte', health: 300, speed: 0.3, grainChance: 0.2, orbChance: 0.5, image: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB4PSIyMCIgeT0iMjAiIHdpZHRoPSI2MCIgaGVpZ2h0PSI2MCIgZmlsbD0iI2E4M2EzYSIvPjwvc3ZnPg==' },
        ],
        levels: [
            { duration: 180, waves: [
                { startTime: 2,   enemyType: 0, spawnInterval: 240 }, { startTime: 30,  enemyType: 0, spawnInterval: 180 },
                { startTime: 70,  enemyType: 1, spawnInterval: 480 }, { startTime: 120, enemyType: 0, spawnInterval: 120 },
                { startTime: 160, enemyType: 1, spawnInterval: 300 },
            ]},
            { duration: 180, waves: [
                { startTime: 2,   enemyType: 0, spawnInterval: 150 }, { startTime: 20,  enemyType: 1, spawnInterval: 240 },
                { startTime: 60,  enemyType: 0, spawnInterval: 90 }, { startTime: 100, enemyType: 1, spawnInterval: 180 }, 
                { startTime: 140, enemyType: 2, spawnInterval: 900 },
            ]}
        ]
    });

    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const gameOverlay = document.getElementById('game-overlay');
    const powerBar = document.getElementById('power-bar');
    const levelValue = document.getElementById('level-value');
    const damageFlash = document.getElementById('damage-flash');

    let cellSize, frame = 0, gameState = 'start', player, base;
    let projectiles = [], enemies = [], resources = [];
    let currentLevelIndex = 0, shootTimer = 0, powerPoints = 0, animationFrameId;
    let levelTimer = 0, currentWaveIndex = -1, spawnTimer = 0;

    const sounds = {
        shoot: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination(),
        collect: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 } }).toDestination(),
        heal: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.2 } }).toDestination(),
        baseHit: new Tone.MembraneSynth({ pitchDecay: 0.1, octaves: 2, envelope: { attack: 0.01, decay: 0.3, sustain: 0.01, release: 0.4 } }).toDestination(),
        enemyHit: new Tone.PolySynth(Tone.NoiseSynth, { noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.05 } }).toDestination(),
        gameOver: new Tone.PolySynth(Tone.Synth).toDestination(),
        levelUp: new Tone.PolySynth(Tone.Synth).toDestination(),
    };

    function playSound(sound, note, duration = '8n') {
        if (Tone.context.state !== 'running') { Tone.start().catch(console.error); }
        if (sounds[sound]) {
            try {
                sounds[sound].triggerAttackRelease(note, duration);
            } catch (e) { /* Fail silently */ }
        }
    }
    
    class Player {
        constructor() { this.reset(); }
        reset() {
            this.width = cellSize * 0.9;
            this.height = cellSize * 0.9;
            // --- MODIFIED: Player is now fixed horizontally at the left edge ---
            this.x = 10; 
            this.y = canvas.height / 2 - this.height / 2;
            this.speed = config.playerSpeed;
            this.image = new Image();
            this.image.src = config.player.image.idle;
            this.attackImage = new Image();
            this.attackImage.src = config.player.image.attack;
            this.isAttacking = false;
        }
        draw() {
            const currentImage = this.isAttacking ? this.attackImage : this.image;
            ctx.drawImage(currentImage, this.x, this.y, this.width, this.height);
        }
        update() {
            if (this.y < 0) this.y = 0;
            if (this.y > canvas.height - this.height) this.y = canvas.height - this.height;
        }
        shoot() {
            if (shootTimer > 0 || gameState !== 'playing') return;
            projectiles.push(new Projectile(this.x + this.width, this.y + this.height / 2));
            shootTimer = config.shootCooldown;
            playSound('shoot', 'C5', '16n');
            this.isAttacking = true;
            setTimeout(() => this.isAttacking = false, 100);
        }
    }
    class Projectile {
        constructor(x, y) {
            this.x = x;
            this.y = y - 10;
            this.width = 20;
            this.height = 20;
            this.speed = config.projectileSpeed;
            this.power = 20;
            this.image = new Image();
            this.image.src = config.player.projectileImage;
        }
        update() { this.x += this.speed; }
        draw() { ctx.drawImage(this.image, this.x, this.y, this.width, this.height); }
    }
    class Enemy {
        constructor(lane, typeIndex) {
            this.type = config.enemies[typeIndex];
            this.width = cellSize - 5 * 2;
            this.height = cellSize - 5 * 2;
            this.x = canvas.width;
            this.y = (lane * cellSize) + 5;
            this.speed = this.type.speed;
            this.health = this.type.health;
            this.maxHealth = this.health;
            this.image = new Image();
            this.image.src = this.type.image;
        }
        update() { this.x -= this.speed; }
        draw() { 
            ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
            if (this.health < this.maxHealth) {
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x, this.y - 10, this.width, 5);
                ctx.fillStyle = 'green';
                ctx.fillRect(this.x, this.y - 10, this.width * (this.health / this.maxHealth), 5);
            }
        }
    }
    class Resource {
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.size = 30;
            this.type = type;
            this.image = new Image();
            this.image.src = type === 'grain' ? config.grainImage : config.orbImage;
            this.life = 400; 
        }
        update() { this.life--; }
        draw() {
            ctx.globalAlpha = this.life < 60 ? this.life / 60 : 1;
            ctx.drawImage(this.image, this.x, this.y, this.size, this.size);
            ctx.globalAlpha = 1;
        }
    }

    function isColliding(a,b){ return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y; }

    function triggerDamageFlash() {
        damageFlash.style.opacity = 1;
        setTimeout(() => { damageFlash.style.opacity = 0; }, 150);
    }

    function handleCollisions() {
        for (let i = projectiles.length - 1; i >= 0; i--) {
            for (let j = enemies.length - 1; j >= 0; j--) {
                if (projectiles[i] && enemies[j] && isColliding(projectiles[i], enemies[j])) {
                    enemies[j].health -= projectiles[i].power;
                    projectiles.splice(i, 1);
                    playSound('enemyHit');
                    if (enemies[j].health <= 0) {
                        const enemyType = enemies[j].type;
                        if (Math.random() < enemyType.grainChance) resources.push(new Resource(enemies[j].x, enemies[j].y, 'grain'));
                        if (Math.random() < enemyType.orbChance) resources.push(new Resource(enemies[j].x, enemies[j].y, 'orb'));
                        enemies.splice(j, 1);
                    }
                    break; 
                }
            }
        }
        for (let i = enemies.length - 1; i >= 0; i--) {
            // --- MODIFIED: Enemies damage the base when they reach the player's area ---
            if (enemies[i].x < player.x + player.width) { 
                base.health -= 50;
                updateTreeAppearance();
                triggerDamageFlash();
                playSound('baseHit', 'C2', '4n');
                enemies.splice(i, 1);
                if (base.health <= 0) {
                    gameState = 'game_over';
                    playSound('gameOver', 'C3', '1n');
                }
            }
        }
    }
    
    function handleGameLogic() {
        if (shootTimer > 0) shootTimer--;
        levelTimer += 1/60;
        projectiles.forEach((p, i) => { p.update(); if (p.x > canvas.width) projectiles.splice(i, 1); });
        enemies.forEach(e => e.update());
        resources.forEach((r, i) => { r.update(); if (r.life <= 0) resources.splice(i, 1); });
        handleCollisions();
        handleLevelProgression();
    }
    function handleLevelProgression() {
        if (gameState !== 'playing') return;
        const currentLevel = config.levels[currentLevelIndex];
        const nextWaveIndex = currentWaveIndex + 1;
        if (nextWaveIndex < currentLevel.waves.length && levelTimer >= currentLevel.waves[nextWaveIndex].startTime) {
            currentWaveIndex = nextWaveIndex;
            spawnTimer = 0;
        }
        if (levelTimer >= currentLevel.duration && enemies.length === 0) {
            startNextLevel();
            return;
        }
        if (currentWaveIndex > -1) {
            if (spawnTimer > 0) {
                spawnTimer--;
            } else if (enemies.length < 20) {
                spawnEnemy();
                spawnTimer = currentLevel.waves[currentWaveIndex].spawnInterval;
            }
        }
    }
    function startNextLevel() { gameState = 'level_complete'; saveGameData(); displayLevelComplete(); }
    function spawnEnemy() {
        const currentWave = config.levels[currentLevelIndex].waves[currentWaveIndex];
        const enemyTypeIndex = currentWave.enemyType;
        const lane = Math.floor(Math.random() * config.lanes);
        enemies.push(new Enemy(lane, enemyTypeIndex));
    }
    function draw() { 
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        player.draw();
        projectiles.forEach(p => p.draw());
        enemies.forEach(e => e.draw());
        resources.forEach(r => r.draw());
        updateUI();
    }
    function updateUI() { 
        levelValue.textContent = currentLevelIndex + 1;
        powerBar.style.width = `${(powerPoints / config.powerBarMax) * 100}%`;
    }
    function gameLoop() {
        if (gameState === 'playing') handleGameLogic();
        draw();
        if (gameState !== 'game_over' && gameState !== 'level_complete') {
            animationFrameId = requestAnimationFrame(gameLoop);
        } else if (gameState === 'game_over') {
            displayGameOver();
        }
    }
    function displayGameOver() {
        cancelAnimationFrame(animationFrameId);
        gameOverlay.style.display = 'flex';
        gameOverlay.innerHTML = `
            <h1>¡Defensa Caída!</h1>
            <p>Las plagas han superado tus defensas.</p>
            <button id="retry-button" class="game-button">Volver a Intentar</button>
        `;
        document.getElementById('retry-button').onclick = () => init(currentLevelIndex, powerPoints, config.base.health);
    }
    function displayLevelComplete() {
        cancelAnimationFrame(animationFrameId);
        const nextLevelExists = currentLevelIndex + 1 < config.levels.length;
        gameOverlay.style.display = 'flex';
        gameOverlay.innerHTML = `
            <h2>¡Nivel ${currentLevelIndex + 1} Superado!</h2>
            ${nextLevelExists ? '<button id="next-level-button" class="game-button">Siguiente Nivel</button>' : '<h1>¡VICTORIA TOTAL!</h1><p>¡Has defendido la cosecha!</p>'}
        `;
        if (nextLevelExists) {
            document.getElementById('next-level-button').onclick = () => {
                currentLevelIndex++;
                init(currentLevelIndex, powerPoints, base.health);
            };
        }
    }
    function init(level = 0, power = 0, health = config.base.health) {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        
        currentLevelIndex = level;
        powerPoints = power;
        base = { health: Math.min(health, config.base.health), maxHealth: config.base.health };
        
        levelTimer = 0;
        currentWaveIndex = -1;
        enemies = [];
        projectiles = [];
        resources = [];

        resizeAll(); 
        updateTreeAppearance();
        updateUI();
        
        gameState = 'start';
        gameOverlay.style.display = 'flex';
        gameOverlay.innerHTML = `
            <h1 id="overlay-title">Runa Defenders</h1>
            <p id="overlay-text">¡Las plagas atacan! Defiende tu cosecha. Mueve a tu Guardián y dispara a los enemigos que vienen de la derecha.</p>
            <button id="start-button" class="game-button">Empezar Nivel ${level + 1}</button>
        `;

        document.getElementById('start-button').onclick = () => {
            if (Tone.context.state !== 'running') { Tone.start(); }
            gameState = 'playing';
            gameOverlay.style.display = 'none';
            spawnTimer = 0;
            gameLoop();
        };
    }
    let keys = {};
    window.addEventListener('keydown', e => { keys[e.key] = true; if (e.key === ' ' || e.key.includes('Arrow')) e.preventDefault(); });
    window.addEventListener('keyup', e => { keys[e.key] = false; });
    let isDragging = false, didDrag = false, touchYOffset = 0, touchStartY = 0;
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        isDragging = true;
        didDrag = false;
        const currentY = touch.clientY - rect.top;
        touchStartY = currentY;
        touchYOffset = currentY - player.y;
    }, { passive: false });
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if (!isDragging) return;
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const newY = touch.clientY - rect.top;
        if (Math.abs(newY - touchStartY) > 5) didDrag = true;
        player.y = newY - touchYOffset;
        player.update();
    }, { passive: false });
    canvas.addEventListener('touchend', e => {
        e.preventDefault();
        if (!didDrag) {
            player.shoot();
            const rect = canvas.getBoundingClientRect();
            const clickX = e.changedTouches[0].clientX - rect.left;
            const clickY = e.changedTouches[0].clientY - rect.top;
            checkResourceClick(clickX, clickY);
        }
        isDragging = false;
    });
    canvas.addEventListener('click', e => {
        const rect = canvas.getBoundingClientRect();
        checkResourceClick(e.clientX - rect.left, e.clientY - rect.top);
        player.shoot();
    });

    function checkResourceClick(x, y) {
        for (let i = resources.length - 1; i >= 0; i--) {
            const r = resources[i];
            const dist = Math.sqrt(Math.pow(x - (r.x + r.size/2), 2) + Math.pow(y - (r.y + r.size/2), 2));
            if (dist < r.size) { 
                if (r.type === 'grain') {
                    base.health = Math.min(base.maxHealth, base.health + config.healingValue);
                    updateTreeAppearance();
                    playSound('heal', 'A5');
                } else {
                    powerPoints = Math.min(config.powerBarMax, powerPoints + config.orbValue);
                    playSound('collect', 'G5');
                }
                resources.splice(i, 1);
                break;
            }
        }
    }

    function controlLoop() {
        if (gameState === 'playing') {
            if (keys['w'] || keys['ArrowUp']) player.y -= player.speed;
            if (keys['s'] || keys['ArrowDown']) player.y += player.speed;
            if (keys[' ']) player.shoot();
            player.update();
        }
        requestAnimationFrame(controlLoop);
    }
    
    function resizeAll() {
        // Resize the main game canvas
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        cellSize = canvas.height / config.lanes;
        
        if (!player) {
            player = new Player();
        } else {
            player.reset();
        }

        // Redraw canvas if game is not running
        if(gameState !== 'playing' && gameState !== 'level_transition'){
            draw();
        }
    }

    // --- INITIALIZE EVERYTHING ---
    initThreeScene();
    window.addEventListener('resize', resizeAll);
    controlLoop();

</script>

</body>
</html>
